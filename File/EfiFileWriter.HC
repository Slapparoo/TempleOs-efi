#include "/Efisource/File/EfiFile.HH"
//*** Generated by /Efisource/File/ReaderToCode.HC

U64 templateSize = 0x1b0;

// this get modified in memory which may not be a great idea, maybe a defensive copy might be better
U8 efiSimpleTemplate[0x1b0] = {0x4d, 
0x5a, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x10, 0x00, 0xff, 
0xff, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
0x00, 0x00, 0x00, 0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09, 0xcd, 0x21, 
0xb8, 0x01, 0x4c, 0xcd, 0x21, 0x54, 0x68, 0x69, 0x73, 0x20, 0x70, 0x72, 
0x6f, 0x67, 0x72, 0x61, 0x6d, 0x20, 0x63, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 
0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6e, 0x20, 0x69, 0x6e, 0x20, 0x44, 
0x4f, 0x53, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x2e, 0x0d, 0x0a, 0x24, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x64, 
0x86, 0x01, 0x00, 0x59, 0x5f, 0x74, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xf0, 0x00, 0x2f, 0x20, 0x0b, 0x02, 0x01, 0x49, 0x00, 
0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0xab, 
0xdb, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x74, 0x65, 0x78, 0x74, 
0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x60, };


U64 offset = 0;
CPeFrontMatter *peFrontMatter = &efiSimpleTemplate[offset];

offset += peFrontMatter->HeaderOffset;
CPeHeader *peHeader = &efiSimpleTemplate[offset];

offset += sizeof(CPeHeader); 
CPe32OptionalHeader *pe32OptionalHeader = &efiSimpleTemplate[offset];

offset += sizeof(CPe32OptionalHeader); 
CPeImageDataDirectory *peImageDataDirectorys = &efiSimpleTemplate[offset];

offset += sizeof(CPeImageDataDirectory) * 16; 
CPeSectionHeader *peSectionHeader0 = &efiSimpleTemplate[offset];


U0 CalcSection(U64 sz) {

/**
PointerToRawData
The file pointer to the first page of the section within the COFF file. For executable images, this must be a multiple of FileAlignment from the optional header. For object files, the value should be aligned on a 4-byte boundary for best performance. When a section contains only uninitialized data, this field should be zero.

SizeOfRawData
The size of the section (for object files) or the size of the initialized data on disk (for image files). For executable images, this must be a multiple of FileAlignment from the optional header. If this is less than VirtualSize, the remainder of the section is zero-filled. Because the SizeOfRawData field is rounded but the VirtualSize field is not, it is possible for SizeOfRawData to be greater than VirtualSize as well. When a section contains only uninitialized data, this field should be zero.
*/

  peSectionHeader0->SizeOfRawData = 
           CeilU64(sz, pe32OptionalHeader->FileAlignment); 
  peSectionHeader0->VirtualSize = sz;  

  "peSectionHeader0->SizeOfRawData x%04x  x%04x\n", sz, peSectionHeader0->SizeOfRawData;

  pe32OptionalHeader->SizeOfCode = peSectionHeader0->SizeOfRawData;  

// PPeSectionHeader->PointerToRawData if there is more than 1 section
  
}
/**
Use the headers defined in this file nad Append on the Binary Section provided
*/


public U0 EfiWriteFile(U8 * filename, U8 * data, U64 sz) {
  CalcSection(sz);

  U8 * warning = "This won't run in TempleOS or";
  MemCpy(peFrontMatter->sometext, warning, StrLen(warning));


  U64 fileSize = peSectionHeader0->PointerToRawData + peSectionHeader0->SizeOfRawData;
  "fileSize 0x%04x %s\n", fileSize, filename;

  U8 *buffer = MAlloc(fileSize);
  U8 *dst = buffer;

  MemCpy(dst, efiSimpleTemplate, templateSize);
  dst = buffer + peSectionHeader0->PointerToRawData;

//  "buffers 0x%016x 0x%016x %d\n", buffer, dst, dst - buffer;
  MemCpy(dst, data, sz);

  // append the data
  FileWrite(filename, buffer, fileSize);

  Free(buffer);
}

/**
 Create a Efi file from the bin File
 provide just the name without extention 
*/
public U0 EfiFromBin(U8* filename) {
  U64 sz = 0;

  U8 * binFName = ExtDft(filename, "BIN.Z");
  U8 * efiFName = ExtDft(filename, "efi");

  U8 * buf = FileRead(binFName, &sz);

  EfiWriteFile(efiFName, &buf[sizeof(CBinFile)], sz - sizeof(CBinFile));

  Free(binFName);
  Free(efiFName);
  Free(buf);
}
